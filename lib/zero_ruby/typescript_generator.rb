# frozen_string_literal: true

module ZeroRuby
  # Generates TypeScript type definitions from registered mutations.
  # Similar to graphql-codegen, this introspects mutation argument definitions
  # and generates corresponding TypeScript interfaces.
  #
  # @example
  #   TypeScriptGenerator.new(ZeroSchema).generate
  #   # => "// Auto-generated by zero-ruby - do not edit\n\nexport interface ..."
  class TypeScriptGenerator
    TYPE_MAP = {
      "ZeroRuby::Types::String" => "string",
      "ZeroRuby::Types::Integer" => "number",
      "ZeroRuby::Types::Float" => "number",
      "ZeroRuby::Types::Boolean" => "boolean",
      "ZeroRuby::Types::ID" => "string",
      "ZeroRuby::Types::BigInt" => "number",
      "ZeroRuby::Types::ISO8601Date" => "string",
      "ZeroRuby::Types::ISO8601DateTime" => "string"
    }.freeze

    def initialize(schema)
      @schema = schema
      @input_objects = {}
    end

    # Generate TypeScript definitions
    # @return [String] Complete TypeScript type definitions
    def generate
      collect_input_objects

      parts = [
        generate_header,
        generate_scalars,
        generate_input_objects,
        generate_mutation_args,
        generate_mutation_map
      ]

      parts.compact.join("\n")
    end

    private

    def generate_header
      <<~TS
        // Auto-generated by zero-ruby - do not edit
        // Generated at: #{Time.now.utc.iso8601}
      TS
    end

    def generate_scalars
      <<~TS

        /** Scalar type mappings */
        export type Scalars = {
          String: string;
          Integer: number;
          Float: number;
          Boolean: boolean;
        };
      TS
    end

    def collect_input_objects
      @schema.mutations.each do |_name, handler_class|
        collect_input_objects_from_arguments(handler_class.arguments)
      end
    end

    def collect_input_objects_from_arguments(arguments)
      arguments.each do |_name, arg|
        if input_object_type?(arg.type)
          type_name = extract_type_name(arg.type)
          unless @input_objects.key?(type_name)
            @input_objects[type_name] = arg.type
            # Recursively collect nested InputObjects
            collect_input_objects_from_arguments(arg.type.arguments)
          end
        end
      end
    end

    def generate_input_objects
      return nil if @input_objects.empty?

      interfaces = @input_objects.map do |name, klass|
        generate_interface(name, klass.arguments)
      end

      "\n" + interfaces.join("\n\n")
    end

    def generate_mutation_args
      return nil if @schema.mutations.empty?

      interfaces = @schema.mutations.map do |name, handler_class|
        interface_name = to_interface_name(name)
        generate_interface(interface_name, handler_class.arguments)
      end

      "\n" + interfaces.join("\n\n")
    end

    def generate_interface(name, arguments)
      if arguments.empty?
        return <<~TS.strip
          /** #{name} */
          export interface #{name} {}
        TS
      end

      fields = arguments.map do |arg_name, arg|
        optional = arg.optional? ? "?" : ""
        ts_type = resolve_type(arg.type)
        description = arg.description ? "  /** #{arg.description} */\n" : ""
        "#{description}  #{to_camel_case(arg_name)}#{optional}: #{ts_type};"
      end

      <<~TS.strip
        /** #{name} */
        export interface #{name} {
        #{fields.join("\n")}
        }
      TS
    end

    def generate_mutation_map
      return nil if @schema.mutations.empty?

      entries = @schema.mutations.map do |name, _handler_class|
        interface_name = to_interface_name(name)
        "  \"#{name}\": #{interface_name};"
      end

      <<~TS

        /** All mutations mapped by name */
        export interface MutationArgs {
        #{entries.join("\n")}
        }

        export type MutationName = keyof MutationArgs;
        export type ArgsFor<T extends MutationName> = MutationArgs[T];
      TS
    end

    def resolve_type(type)
      type_key = type.to_s

      if TYPE_MAP.key?(type_key)
        TYPE_MAP[type_key]
      elsif input_object_type?(type)
        extract_type_name(type)
      else
        # Unknown type, default to unknown
        "unknown"
      end
    end

    def input_object_type?(type)
      defined?(ZeroRuby::InputObject) && type.is_a?(Class) && type < ZeroRuby::InputObject
    end

    def extract_type_name(type)
      # Get just the class name without module prefixes
      type.name.split("::").last
    end

    # Convert mutation name to interface name
    # "todo.create" -> "TodoCreateArgs"
    # "posts.bulk_update" -> "PostsBulkUpdateArgs"
    def to_interface_name(mutation_name)
      parts = mutation_name.to_s.split(".")
      pascal = parts.map { |part| to_pascal_case(part) }.join
      "#{pascal}Args"
    end

    # Convert snake_case to PascalCase
    def to_pascal_case(str)
      str.to_s.split("_").map(&:capitalize).join
    end

    # Convert snake_case to camelCase
    def to_camel_case(name)
      parts = name.to_s.split("_")
      return parts.first if parts.length == 1
      parts.first + parts[1..].map(&:capitalize).join
    end
  end
end
