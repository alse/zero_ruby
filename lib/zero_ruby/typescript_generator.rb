# frozen_string_literal: true

module ZeroRuby
  # Generates TypeScript type definitions from registered mutations.
  # Similar to graphql-codegen, this introspects mutation argument definitions
  # and generates corresponding TypeScript interfaces.
  #
  # @example
  #   TypeScriptGenerator.new(ZeroSchema).generate
  #   # => "// Auto-generated by zero-ruby - do not edit\n\nexport interface ..."
  class TypeScriptGenerator
    # Map Ruby primitives to TypeScript types
    PRIMITIVE_MAP = {
      String => "string",
      Integer => "number",
      Float => "number",
      TrueClass => "boolean",
      FalseClass => "boolean",
      Date => "string",
      DateTime => "string",
      Time => "string"
    }.freeze

    def initialize(schema)
      @schema = schema
      @input_objects = {}
    end

    # Generate TypeScript definitions
    # @return [String] Complete TypeScript type definitions
    def generate
      collect_input_objects

      parts = [
        generate_header,
        generate_input_objects,
        generate_mutation_args,
        generate_mutation_map
      ]

      parts.compact.join("\n")
    end

    private

    def generate_header
      <<~TS
        // Auto-generated by zero-ruby - do not edit
      TS
    end

    def collect_input_objects
      @schema.mutations.each do |_name, handler_class|
        collect_input_objects_from_arguments(handler_class.arguments)
      end
    end

    def collect_input_objects_from_arguments(arguments)
      arguments.each do |_name, config|
        type = config[:type]

        # Unwrap optional types first (Sum type: NilClass | actual_type)
        if sum_type?(type)
          inner = extract_non_nil_type(type)
          type = inner if inner
        end

        # Then unwrap array types to check element type for InputObjects
        if array_type?(type)
          type = type.member
        end

        if input_object_type?(type)
          type_name = extract_type_name(type)
          unless @input_objects.key?(type_name)
            @input_objects[type_name] = type
            # Recursively collect nested InputObjects from Dry::Struct schema
            if type.respond_to?(:schema)
              nested_args = type.schema.keys.each_with_object({}) do |key, hash|
                hash[key.name] = {type: key.type, name: key.name}
              end
              collect_input_objects_from_arguments(nested_args)
            end
          end
        end
      end
    end

    def generate_input_objects
      return nil if @input_objects.empty?

      interfaces = @input_objects.map do |name, klass|
        generate_input_object_interface(name, klass)
      end

      "\n" + interfaces.join("\n\n")
    end

    def generate_input_object_interface(name, klass)
      return empty_interface(name) unless klass.respond_to?(:schema)

      keys = klass.schema.keys
      return empty_interface(name) if keys.empty?

      fields = keys.map do |key|
        # Check if the type itself is optional (not just the key)
        optional = optional_type?(key.type)
        optional_mark = optional ? "?" : ""
        ts_type = resolve_type(key.type)
        ts_type = "#{ts_type} | null" if optional
        "  #{to_camel_case(key.name)}#{optional_mark}: #{ts_type};"
      end

      <<~TS.strip
        /** #{name} */
        export interface #{name} {
        #{fields.join("\n")}
        }
      TS
    end

    def generate_mutation_args
      return nil if @schema.mutations.empty?

      interfaces = @schema.mutations.map do |name, handler_class|
        interface_name = to_interface_name(name)
        generate_mutation_interface(interface_name, handler_class.arguments)
      end

      "\n" + interfaces.join("\n\n")
    end

    def generate_mutation_interface(name, arguments)
      return empty_interface(name) if arguments.empty?

      fields = arguments.map do |arg_name, config|
        type = config[:type]
        optional = optional_type?(type)
        optional_mark = optional ? "?" : ""
        ts_type = resolve_type(type)
        ts_type = "#{ts_type} | null" if optional
        description = config[:description] ? "  /** #{config[:description]} */\n" : ""
        "#{description}  #{to_camel_case(arg_name)}#{optional_mark}: #{ts_type};"
      end

      <<~TS.strip
        /** #{name} */
        export interface #{name} {
        #{fields.join("\n")}
        }
      TS
    end

    def empty_interface(name)
      <<~TS.strip
        /** #{name} */
        export interface #{name} {}
      TS
    end

    def generate_mutation_map
      return nil if @schema.mutations.empty?

      entries = @schema.mutations.map do |name, _handler_class|
        interface_name = to_interface_name(name)
        "  \"#{name}\": #{interface_name};"
      end

      <<~TS

        /** All mutations mapped by name */
        export interface MutationArgs {
        #{entries.join("\n")}
        }
      TS
    end

    def resolve_type(type)
      # Handle InputObject classes
      if input_object_type?(type)
        return extract_type_name(type)
      end

      # Handle Array types
      if array_type?(type)
        element_type = type.member
        return "#{resolve_type(element_type)}[]"
      end

      # Handle optional types (Sum of NilClass and another type)
      # This must come before unwrap_primitive to handle optional arrays
      if sum_type?(type)
        inner = extract_non_nil_type(type)
        return resolve_type(inner) if inner
      end

      # Unwrap the dry-type to get the primitive
      primitive = unwrap_primitive(type)

      # Check if it's a nested InputObject after unwrapping
      if input_object_type?(primitive)
        return extract_type_name(primitive)
      end

      # Map primitive to TypeScript
      PRIMITIVE_MAP[primitive] || raise(
        ArgumentError,
        "Cannot map type #{type.inspect} (primitive: #{primitive.inspect}) to TypeScript. " \
        "Supported primitives: #{PRIMITIVE_MAP.keys.map(&:name).join(", ")}"
      )
    end

    # Unwrap dry-types wrappers to get the underlying primitive
    def unwrap_primitive(type)
      # Check for Sum type (optional = NilClass | type)
      # For optional types, left is NilClass, right is the actual type
      if type.respond_to?(:left) && type.respond_to?(:right)
        left_primitive = unwrap_primitive(type.left)
        right_primitive = unwrap_primitive(type.right)
        # Return the non-NilClass side
        return right_primitive if left_primitive == NilClass
        return left_primitive if right_primitive == NilClass
        # If neither is NilClass, return left (shouldn't happen for optional)
        return left_primitive
      end

      # Try to get the primitive directly
      if type.respond_to?(:primitive)
        return type.primitive
      end

      # Check for Constrained type
      if type.respond_to?(:type) && type.class.name&.include?("Constrained")
        return unwrap_primitive(type.type)
      end

      # Check for Default type
      if type.respond_to?(:type) && type.class.name&.include?("Default")
        return unwrap_primitive(type.type)
      end

      # Check for other wrappers with .type method
      if type.respond_to?(:type)
        return unwrap_primitive(type.type)
      end

      type
    end

    def optional_type?(type)
      return false unless type.respond_to?(:optional?)
      type.optional? || (type.respond_to?(:default?) && type.default?)
    end

    def input_object_type?(type)
      type.is_a?(Class) && type < ZeroRuby::InputObject
    end

    def array_type?(type)
      type.respond_to?(:primitive) && type.primitive == Array
    end

    def sum_type?(type)
      type.respond_to?(:left) && type.respond_to?(:right)
    end

    def extract_non_nil_type(type)
      return nil unless sum_type?(type)
      if type.left.respond_to?(:primitive) && type.left.primitive == NilClass
        type.right
      elsif type.right.respond_to?(:primitive) && type.right.primitive == NilClass
        type.left
      end
    end

    def extract_type_name(type)
      # Get just the class name without module prefixes
      type.name.split("::").last
    end

    # Convert mutation name to interface name
    # "todo.create" -> "TodoCreateArgs"
    # "posts.bulk_update" -> "PostsBulkUpdateArgs"
    def to_interface_name(mutation_name)
      parts = mutation_name.to_s.split(".")
      pascal = parts.map { |part| to_pascal_case(part) }.join
      "#{pascal}Args"
    end

    # Convert snake_case to PascalCase
    def to_pascal_case(str)
      str.to_s.split("_").map(&:capitalize).join
    end

    # Convert snake_case to camelCase
    def to_camel_case(name)
      parts = name.to_s.split("_")
      return parts.first if parts.length == 1
      parts.first + parts[1..].map(&:capitalize).join
    end
  end
end
