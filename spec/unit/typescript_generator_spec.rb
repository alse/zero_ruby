# frozen_string_literal: true

require "spec_helper"

# Test InputObject for generator tests (prefixed with TSGen to avoid conflicts)
class TSGenTodoInput < ZeroRuby::InputObject
  argument :id, ZeroRuby::Types::String
  argument :title, ZeroRuby::Types::String
  argument :completed, ZeroRuby::Types::Boolean.optional
end

# Test nested InputObject
class TSGenAuthorInput < ZeroRuby::InputObject
  argument :name, ZeroRuby::Types::String
  argument :email, ZeroRuby::Types::String.optional
end

class TSGenPostInput < ZeroRuby::InputObject
  argument :id, ZeroRuby::Types::String
  argument :title, ZeroRuby::Types::String, description: "The post title"
  argument :author, TSGenAuthorInput
end

# Test mutation with primitive types
class TSTodoCreate < ZeroRuby::Mutation
  argument :id, ZeroRuby::Types::String
  argument :title, ZeroRuby::Types::String
  argument :completed, ZeroRuby::Types::Boolean.optional

  def execute
  end
end

# Test mutation with InputObject
class TSPostCreate < ZeroRuby::Mutation
  argument :post, TSGenPostInput
  argument :notify, ZeroRuby::Types::Boolean.optional

  def execute
  end
end

# Test mutation with various types
class TSItemUpdate < ZeroRuby::Mutation
  argument :id, ZeroRuby::Types::String
  argument :quantity, ZeroRuby::Types::Integer.optional
  argument :price, ZeroRuby::Types::Float.optional
  argument :active, ZeroRuby::Types::Boolean.optional

  def execute
  end
end

# Test schema with multiple mutations
class TSTestSchema < ZeroRuby::Schema
  mutation "todo.create", handler: TSTodoCreate
  mutation "posts.create", handler: TSPostCreate
  mutation "items.update", handler: TSItemUpdate
end

# Empty schema for edge case
class TSEmptySchema < ZeroRuby::Schema
end

# Test mutation with date/time types
class TSDateMutation < ZeroRuby::Mutation
  argument :start_date, ZeroRuby::Types::ISO8601Date
  argument :end_date, ZeroRuby::Types::ISO8601Date.optional
  argument :created_at, ZeroRuby::Types::ISO8601DateTime
  argument :updated_at, ZeroRuby::Types::ISO8601DateTime.optional

  def execute
  end
end

# Test mutation with ID type
class TSIdMutation < ZeroRuby::Mutation
  argument :id, ZeroRuby::Types::ID
  argument :parent_id, ZeroRuby::Types::ID.optional

  def execute
  end
end

# Test mutation with default values
class TSDefaultMutation < ZeroRuby::Mutation
  argument :status, ZeroRuby::Types::String.default("draft")
  argument :count, ZeroRuby::Types::Integer.default(0)
  argument :enabled, ZeroRuby::Types::Boolean.default(true)

  def execute
  end
end

# Test mutation with constrained types
class TSConstrainedMutation < ZeroRuby::Mutation
  argument :title, ZeroRuby::Types::String.constrained(max_size: 200)
  argument :age, ZeroRuby::Types::Integer.constrained(gt: 0, lt: 150)
  argument :slug, ZeroRuby::Types::String.constrained(format: /^[a-z-]+$/)

  def execute
  end
end

# Empty InputObject
class TSEmptyInput < ZeroRuby::InputObject
end

# Test mutation with empty InputObject
class TSEmptyInputMutation < ZeroRuby::Mutation
  argument :data, TSEmptyInput

  def execute
  end
end

# Test mutation with no arguments
class TSNoArgsMutation < ZeroRuby::Mutation
  def execute
  end
end

# Extended schema with all type variations
class TSExtendedSchema < ZeroRuby::Schema
  mutation "dates.create", handler: TSDateMutation
  mutation "ids.create", handler: TSIdMutation
  mutation "defaults.create", handler: TSDefaultMutation
  mutation "constrained.create", handler: TSConstrainedMutation
  mutation "empty.create", handler: TSEmptyInputMutation
  mutation "noargs.create", handler: TSNoArgsMutation
end

describe "TypeScript Generator" do
  let(:output) { TSTestSchema.to_typescript }

  it "generates header" do
    expect(output).to include("// Auto-generated by zero-ruby - do not edit")
  end

  it "generates mutation args interface" do
    expect(output).to include("export interface TodoCreateArgs {")
    expect(output).to include("id: string;")
    expect(output).to include("title: string;")
    expect(output).to include("completed?: boolean | null;")
  end

  it "generates input object interfaces" do
    expect(output).to include("export interface TSGenPostInput {")
    expect(output).to include("export interface TSGenAuthorInput {")
  end

  it "generates mutation map" do
    expect(output).to include("export interface MutationArgs {")
    expect(output).to include('"todo.create": TodoCreateArgs;')
    expect(output).to include('"posts.create": PostsCreateArgs;')
    expect(output).to include('"items.update": ItemsUpdateArgs;')
  end

  it "handles empty schema" do
    empty_output = TSEmptySchema.to_typescript

    expect(empty_output).to include("// Auto-generated by zero-ruby")
    expect(empty_output).not_to include("export interface MutationArgs")
  end

  it "references input object types" do
    expect(output).to include("post: TSGenPostInput;")
  end

  it "references nested input object types" do
    expect(output).to include("author: TSGenAuthorInput;")
  end

  it "uses correct interface naming convention" do
    expect(output).to include("TodoCreateArgs")
    expect(output).to include("PostsCreateArgs")
    expect(output).to include("ItemsUpdateArgs")
  end
end

# Test with snake_case arguments
class TSSnakeCaseMutation < ZeroRuby::Mutation
  argument :user_id, ZeroRuby::Types::String
  argument :is_active, ZeroRuby::Types::Boolean.optional
  argument :created_at, ZeroRuby::Types::String.optional

  def execute
  end
end

class TSSnakeCaseSchema < ZeroRuby::Schema
  mutation "users.update", handler: TSSnakeCaseMutation
end

describe "TypeScript Generator snake_case conversion" do
  it "converts snake_case to camelCase" do
    output = TSSnakeCaseSchema.to_typescript

    expect(output).to include("userId: string;")
    expect(output).to include("isActive?: boolean | null;")
    expect(output).to include("createdAt?: string | null;")
  end
end

describe "TypeScript Generator extended types" do
  let(:output) { TSExtendedSchema.to_typescript }

  describe "date/time types" do
    it "maps ISO8601Date to string" do
      expect(output).to include("startDate: string;")
      expect(output).to include("endDate?: string | null;")
    end

    it "maps ISO8601DateTime to string" do
      expect(output).to include("createdAt: string;")
      expect(output).to include("updatedAt?: string | null;")
    end
  end

  describe "ID type" do
    it "maps ID to string" do
      expect(output).to include("id: string;")
      expect(output).to include("parentId?: string | null;")
    end
  end

  describe "default values" do
    it "treats default fields as optional with null" do
      # Default types are treated as optional and can be null
      expect(output).to include("status?: string | null;")
      expect(output).to include("count?: number | null;")
      expect(output).to include("enabled?: boolean | null;")
    end
  end

  describe "constrained types" do
    it "unwraps constraints to base types" do
      expect(output).to include("title: string;")
      expect(output).to include("age: number;")
      expect(output).to include("slug: string;")
    end
  end

  describe "empty InputObject" do
    it "generates empty interface for empty InputObject" do
      expect(output).to include("export interface TSEmptyInput {")
      expect(output).to include("}")
    end
  end

  describe "mutation with no arguments" do
    it "generates empty interface for mutation with no args" do
      expect(output).to include("export interface NoargsCreateArgs {")
    end
  end

  describe "mutation map includes all mutations" do
    it "includes all mutation types in the map" do
      expect(output).to include('"dates.create": DatesCreateArgs;')
      expect(output).to include('"ids.create": IdsCreateArgs;')
      expect(output).to include('"defaults.create": DefaultsCreateArgs;')
      expect(output).to include('"constrained.create": ConstrainedCreateArgs;')
      expect(output).to include('"empty.create": EmptyCreateArgs;')
      expect(output).to include('"noargs.create": NoargsCreateArgs;')
    end
  end
end

# Deeply nested InputObjects for testing
class TSGenAddressInput < ZeroRuby::InputObject
  argument :street, ZeroRuby::Types::String
  argument :city, ZeroRuby::Types::String
end

class TSGenContactInput < ZeroRuby::InputObject
  argument :email, ZeroRuby::Types::String
  argument :address, TSGenAddressInput
end

class TSGenPersonInput < ZeroRuby::InputObject
  argument :name, ZeroRuby::Types::String
  argument :contact, TSGenContactInput
end

class TSDeepNestedMutation < ZeroRuby::Mutation
  argument :person, TSGenPersonInput

  def execute
  end
end

class TSDeepNestedSchema < ZeroRuby::Schema
  mutation "people.create", handler: TSDeepNestedMutation
end

# InputObject with field descriptions
class TSDescribedInput < ZeroRuby::InputObject
  argument :name, ZeroRuby::Types::String, description: "User's full name"
  argument :age, ZeroRuby::Types::Integer, description: "Age in years"
  argument :email, ZeroRuby::Types::String.optional
end

class TSDescribedMutation < ZeroRuby::Mutation
  argument :user, TSDescribedInput, description: "User data"

  def execute
  end
end

class TSDescribedSchema < ZeroRuby::Schema
  mutation "users.create", handler: TSDescribedMutation
end

describe "TypeScript Generator deeply nested InputObjects" do
  let(:output) { TSDeepNestedSchema.to_typescript }

  it "generates all nested InputObject interfaces" do
    expect(output).to include("export interface TSGenPersonInput {")
    expect(output).to include("export interface TSGenContactInput {")
    expect(output).to include("export interface TSGenAddressInput {")
  end

  it "correctly references nested types at each level" do
    expect(output).to include("contact: TSGenContactInput;")
    expect(output).to include("address: TSGenAddressInput;")
  end

  it "collects all InputObjects transitively" do
    # All three levels of nesting should be included
    expect(output.scan(/export interface TSGen\w+Input/).length).to be >= 3
  end
end

describe "TypeScript Generator InputObject descriptions" do
  let(:output) { TSDescribedSchema.to_typescript }

  it "includes InputObject with described fields in output" do
    expect(output).to include("export interface TSDescribedInput {")
  end

  it "generates mutation args with InputObject reference" do
    expect(output).to include("user: TSDescribedInput;")
  end
end

describe "TypeScript Generator array types" do
  it "generates TypeScript for array of strings" do
    array_mutation = Class.new(ZeroRuby::Mutation) do
      argument :tags, Dry::Types["array"].of(Dry::Types["string"])

      def execute
      end
    end

    array_schema = Class.new(ZeroRuby::Schema) do
      mutation "tags.create", handler: array_mutation
    end

    output = array_schema.to_typescript
    expect(output).to include("tags: string[];")
  end

  it "generates TypeScript for array of IDs" do
    array_mutation = Class.new(ZeroRuby::Mutation) do
      argument :tag_ids, ZeroRuby::Types::Array.of(ZeroRuby::Types::ID)

      def execute
      end
    end

    array_schema = Class.new(ZeroRuby::Schema) do
      mutation "tags.update", handler: array_mutation
    end

    output = array_schema.to_typescript
    expect(output).to include("tagIds: string[];")
  end

  it "generates TypeScript for optional array of IDs" do
    array_mutation = Class.new(ZeroRuby::Mutation) do
      argument :tag_ids, ZeroRuby::Types::Array.of(ZeroRuby::Types::ID).optional

      def execute
      end
    end

    array_schema = Class.new(ZeroRuby::Schema) do
      mutation "tags.update", handler: array_mutation
    end

    output = array_schema.to_typescript
    expect(output).to include("tagIds?: string[] | null;")
  end
end
