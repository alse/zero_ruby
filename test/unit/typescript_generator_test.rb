# frozen_string_literal: true

require_relative "../test_helper"

# Test InputObject for generator tests (prefixed with TSGen to avoid conflicts)
class TSGenTodoInput < ZeroRuby::InputObject
  argument :id, ZeroRuby::Types::String, required: true
  argument :title, ZeroRuby::Types::String, required: true
  argument :completed, ZeroRuby::Types::Boolean, required: false
end

# Test nested InputObject
class TSGenAuthorInput < ZeroRuby::InputObject
  argument :name, ZeroRuby::Types::String, required: true
  argument :email, ZeroRuby::Types::String, required: false
end

class TSGenPostInput < ZeroRuby::InputObject
  argument :id, ZeroRuby::Types::String, required: true
  argument :title, ZeroRuby::Types::String, required: true, description: "The post title"
  argument :author, TSGenAuthorInput, required: true
end

# Test mutation with primitive types
class TSTodoCreate < ZeroRuby::Mutation
  argument :id, ZeroRuby::Types::String, required: true
  argument :title, ZeroRuby::Types::String, required: true
  argument :completed, ZeroRuby::Types::Boolean, required: false

  def execute(**)
  end
end

# Test mutation with InputObject
class TSPostCreate < ZeroRuby::Mutation
  argument :post, TSGenPostInput, required: true
  argument :notify, ZeroRuby::Types::Boolean, required: false

  def execute(**)
  end
end

# Test mutation with various types
class TSItemUpdate < ZeroRuby::Mutation
  argument :id, ZeroRuby::Types::String, required: true
  argument :quantity, ZeroRuby::Types::Integer, required: false
  argument :price, ZeroRuby::Types::Float, required: false
  argument :active, ZeroRuby::Types::Boolean, required: false

  def execute(**)
  end
end

# Test schema with multiple mutations
class TSTestSchema < ZeroRuby::Schema
  mutation "todo.create", handler: TSTodoCreate
  mutation "posts.create", handler: TSPostCreate
  mutation "items.update", handler: TSItemUpdate
end

# Empty schema for edge case
class TSEmptySchema < ZeroRuby::Schema
end

class TypeScriptGeneratorTest < Minitest::Test
  def test_generates_header
    output = TSTestSchema.to_typescript

    assert_includes output, "// Auto-generated by zero-ruby - do not edit"
    assert_includes output, "// Generated at:"
  end

  def test_generates_scalars
    output = TSTestSchema.to_typescript

    assert_includes output, "export type Scalars = {"
    assert_includes output, "String: string;"
    assert_includes output, "Integer: number;"
    assert_includes output, "Float: number;"
    assert_includes output, "Boolean: boolean;"
  end

  def test_generates_mutation_args_interface
    output = TSTestSchema.to_typescript

    # Check todo.create generates TodoCreateArgs
    assert_includes output, "export interface TodoCreateArgs {"
    assert_includes output, "id: string;"
    assert_includes output, "title: string;"
    assert_includes output, "completed?: boolean;"
  end

  def test_generates_input_object_interfaces
    output = TSTestSchema.to_typescript

    # Check TSGenPostInput generates interface
    assert_includes output, "export interface TSGenPostInput {"
    # Check nested TSGenAuthorInput generates interface
    assert_includes output, "export interface TSGenAuthorInput {"
  end

  def test_generates_mutation_map
    output = TSTestSchema.to_typescript

    assert_includes output, "export interface MutationArgs {"
    assert_includes output, '"todo.create": TodoCreateArgs;'
    assert_includes output, '"posts.create": PostsCreateArgs;'
    assert_includes output, '"items.update": ItemsUpdateArgs;'
  end

  def test_generates_helper_types
    output = TSTestSchema.to_typescript

    assert_includes output, "export type MutationName = keyof MutationArgs;"
    assert_includes output, "export type ArgsFor<T extends MutationName> = MutationArgs[T];"
  end

  def test_handles_empty_schema
    output = TSEmptySchema.to_typescript

    assert_includes output, "// Auto-generated by zero-ruby"
    assert_includes output, "export type Scalars"
    # Should not crash, just not have mutation-specific output
    refute_includes output, "export interface MutationArgs"
  end

  def test_maps_string_type
    output = TSTestSchema.to_typescript

    # String type should map to string
    assert_match(/id: string;/, output)
  end

  def test_maps_integer_type
    output = TSTestSchema.to_typescript

    # Integer type should map to number
    assert_includes output, "quantity?: number;"
  end

  def test_maps_float_type
    output = TSTestSchema.to_typescript

    # Float type should map to number
    assert_includes output, "price?: number;"
  end

  def test_maps_boolean_type
    output = TSTestSchema.to_typescript

    # Boolean type should map to boolean
    assert_includes output, "active?: boolean;"
  end

  def test_optional_fields_have_question_mark
    output = TSTestSchema.to_typescript

    # Optional fields should have ?
    assert_includes output, "completed?: boolean;"
    assert_includes output, "notify?: boolean;"
  end

  def test_required_fields_no_question_mark
    output = TSTestSchema.to_typescript

    # Required fields should not have ?
    # Using regex to check "id:" without "?" before the colon
    assert_match(/\bid: string;/, output)
    assert_match(/\btitle: string;/, output)
  end

  def test_input_object_reference
    output = TSTestSchema.to_typescript

    # PostsCreateArgs should reference TSGenPostInput
    assert_includes output, "post: TSGenPostInput;"
  end

  def test_nested_input_object_reference
    output = TSTestSchema.to_typescript

    # TSGenPostInput should reference TSGenAuthorInput
    assert_includes output, "author: TSGenAuthorInput;"
  end

  def test_interface_naming_convention
    output = TSTestSchema.to_typescript

    # "todo.create" -> "TodoCreateArgs"
    assert_includes output, "TodoCreateArgs"
    # "posts.create" -> "PostsCreateArgs"
    assert_includes output, "PostsCreateArgs"
    # "items.update" -> "ItemsUpdateArgs"
    assert_includes output, "ItemsUpdateArgs"
  end

  def test_snake_case_to_camel_case_conversion
    # Covered by TypeScriptGeneratorSnakeCaseTest below
  end

  def test_output_is_valid_typescript_structure
    output = TSTestSchema.to_typescript

    # Basic structural validation
    assert_match(/export type Scalars = \{/, output)
    assert_match(/export interface \w+Args \{/, output)
    assert_match(/export interface MutationArgs \{/, output)
    assert_match(/export type MutationName = keyof MutationArgs;/, output)
  end
end

# Test with snake_case arguments
class TSSnakeCaseMutation < ZeroRuby::Mutation
  argument :user_id, ZeroRuby::Types::String, required: true
  argument :is_active, ZeroRuby::Types::Boolean, required: false
  argument :created_at, ZeroRuby::Types::String, required: false

  def execute(**)
  end
end

class TSSnakeCaseSchema < ZeroRuby::Schema
  mutation "users.update", handler: TSSnakeCaseMutation
end

class TypeScriptGeneratorSnakeCaseTest < Minitest::Test
  def test_converts_snake_case_to_camel_case
    output = TSSnakeCaseSchema.to_typescript

    # snake_case arguments should become camelCase in TypeScript
    assert_includes output, "userId: string;"
    assert_includes output, "isActive?: boolean;"
    assert_includes output, "createdAt?: string;"
  end
end
